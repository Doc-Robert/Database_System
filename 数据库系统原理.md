

# 数据库系统原理



# 第一章 数据库系统概述

## 1.1 数据库基本概念

**数据**（Data）**是描述书屋的符号记录**，是指用物理符号记录下来的，可以鉴别的信息

![image-20210301190853315](数据库系统原理.assets/image-20210301190853315.png)



**数据库** （Database，简称DB）**是长期储存在计算机有组织，可共享的大量数据集合。**

数据库中存储的数据具有**永久存储**、**有组织**和**可共享**三个基本特点



**数据库管理系统**（Database Management System 简称DBMS）是位于**用户与操作系统**之间的一层**数据管理软件**

主要功能：
1.**数据定义功能**

提供数据定义语言（DDL）定义数据库中的数据

![image-20210301191816509](数据库系统原理.assets/image-20210301191816509.png)



2.**数据操纵功能**

提供数据操纵语言（DML）操纵数据实现对数据库的基本操作

![image-20210301191942108](数据库系统原理.assets/image-20210301191942108.png)



3.**数据库的运行管理**

![image-20210301192046011](数据库系统原理.assets/image-20210301192046011.png)



4.**数据库的建立和维护功能**

![image-20210301192434259](数据库系统原理.assets/image-20210301192434259.png)

5.**数据组织、存储 和管理功能**

![image-20210301192441083](数据库系统原理.assets/image-20210301192441083.png)

6.**其他功能**

![image-20210301192539570](数据库系统原理.assets/image-20210301192539570.png)





**数据库系统**（Database System ，DBS）是在计算机中引入数据库技术之后的系统

![image-20210301192723755](数据库系统原理.assets/image-20210301192723755.png)



## 1.2 数据库管理技术的发展

### 1.人工管理阶段

![image-20210301192843093](数据库系统原理.assets/image-20210301192843093.png)

### 2. 文件系统阶段

![image-20210301193109070](数据库系统原理.assets/image-20210301193109070.png)



### 3. 数据库系统阶段

![image-20210301193516495](数据库系统原理.assets/image-20210301193516495.png)





## 1.3 数据库系统的结构

### 1.3.1 数据库系统的三级模式结构

**1.模式**

![image-20210301193712627](数据库系统原理.assets/image-20210301193712627.png)



**2.外模式** 

​	外模式也称为子模式（Subschema）或用户模式，它被数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑和特征的描述

![image-20210301194047098](数据库系统原理.assets/image-20210301194047098.png)



**3.内模式**

​	内模式也称为存储模式（Storage Schema）它是对数据库中数据物理结构和存储方式的描述，是数据在数据库内部的表示形式



**4.三级模式结构的两层映像与数据独立性**

数据独立性包括两个

**（1）外模式/模式映像**（逻辑独立性）

**（2）模式/内模式映像**（物理独立性）



例题：

![image-20210301194936957](数据库系统原理.assets/image-20210301194936957.png)





### 1.3.2 数据库系统的运行与应用结构

**1.客户/服务器 （Client/Server, C/S）模式**

![image-20210301195156011](数据库系统原理.assets/image-20210301195156011.png)

**2.浏览器/服务器 （Browser/Server ，B/S）模式**

![image-20210301195202299](数据库系统原理.assets/image-20210301195202299.png)





## 1.4 数据模型

### 1.4.1 数据特征与数据模型组成要素

**1.数据结构**

​	数据结构描述的是系统的**静态属性**

![image-20210301195829435](数据库系统原理.assets/image-20210301195829435.png)

**2.数据操作**

​	数据操作描述的是系统的动态属性

![image-20210301195853692](数据库系统原理.assets/image-20210301195853692.png)

3.数据的约束条件

![image-20210301195917947](数据库系统原理.assets/image-20210301195917947.png)



### 1.4.2 数据模型的分类

#### **1.概念层数据模型**

（1）信息世界中的基本概念

- **实体（Entity）**

客观存在并可相互区别的事务称为实体。可以是具体的人、事、物或抽象的概念

- **属性（Attribute）**

实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画

- **码（key）**

唯一标识实体的**属性集**称为码

- **域（Domain）**

属性的取值范围称为该属性的域

- **实体型（Entity Type）**

用实体名及其属性名集合来抽象和刻画。同类实体称为实体型

- **实体集（Entity Set）**

同型实体的集合称为实体集 

- **联系（Relationship）**

![image-20210301201212477](数据库系统原理.assets/image-20210301201212477.png)

实体型关系：

- **一对多** 1：N
- **一对一** 1:1
- **多对多** N:M



（2）**概念模型的表示方法**

概念模型：用来描述现实世界的事物，与具体的计算机系统无关

![image-20210301201607515](数据库系统原理.assets/image-20210301201607515.png)

E-R图

![image-20210301201727720](数据库系统原理.assets/image-20210301201727720.png)





#### 2.逻辑层数据模型

（1）层次模型

（2）网状模型

（3）**关系模型**

（4）面向对象模型



#### 3.物理层数据模型

![image-20210301202007823](数据库系统原理.assets/image-20210301202007823.png)





## 小结

![image-20210301202124505](数据库系统原理.assets/image-20210301202124505.png)



![image-20210301202150321](数据库系统原理.assets/image-20210301202150321.png)







# 第二章 关系数据库

## 2.1 关系数据库概述

![image-20210302140220258](数据库系统原理.assets/image-20210302140220258.png)





## 2.2 关系数据模型

### 2.2.1关系数据结构

​	关系模型的数据结构非常简单，只包含单一的数据结构，即关系。-》**二维表**

![image-20210302140810538](数据库系统原理.assets/image-20210302140810538.png)



基本术语：

1. **表（Table）**

表，也称为关系 ，是一个二维的数据结构，由表名、构成表的各个列（如学号、姓名等）及若干行数据（每个学生的具体信息）组成

2. **关系（Relation）**

一个关系逻辑上对应一张二维表，可以为每个关系取个名称进行标识

3. **列（Column）**

表中的列，也称为字段（Field）或属性（Attribute）

表中每一列有一个名称，称为列名、字段名或属性名

一列表示实体的一个属性，`具有相同的数据类型`

4. **属性（Attribute）**

表中的一列即为一个属性，给每一个属性起一个名称或属性名。与之同义的术语是“**列**”。表中属性的个数称为关系的**元**或**度**。列的值称为属性值；属性值的取值范围称为 **值域**

5. **行（Row）**

表中的行（Row），也称为元组（Tuple）或记录（Record）

6. **元组（Tuple）**

表中的一行即为一个元组

![image-20210302142152468](数据库系统原理.assets/image-20210302142152468.png)

7. **分量（Component）**

元组中的一个属性值，称为分量

8. **码或键（key）**

![image-20210302142512596](数据库系统原理.assets/image-20210302142512596.png)

9. **超码或超键（Super Key）**

如果在关系的一个码移去某个属性，它任然是这个关系的码，则称这样的码或键为该关系的**超码或超键**

10. **候选码或候选键 （Candidate Key）**

![image-20210302142902420](数据库系统原理.assets/image-20210302142902420.png)

注意：候选码不是 **码**

11. **主键和主码**

在一个关系的若干个候选码或候选键中指定一个用来唯一标识的元组，则称这个被指定的候选码或候选键为该关系的主码或主键

12. **全码或全健**

![image-20210302143237663](数据库系统原理.assets/image-20210302143237663.png)



13. **主属性（Primary Attribute）和非主属性（Nonprimary Attribute）**

![image-20210302143526855](数据库系统原理.assets/image-20210302143526855.png)

14. **外码或外键（Foreign Key）***

![image-20210302144115588](数据库系统原理.assets/image-20210302144115588.png)

15. **参照关系（Referencing Relation）和被参照关系（Referenced Relation）**

参照关系也称为从关系，被参照关系也称为主关系，它们是指以外码相关联的两个关系。

![image-20210302144525397](数据库系统原理.assets/image-20210302144525397.png)

16. **域（Domain）**

域表示属性的取值范围

17. **数据类型（Data Type）**

![image-20210302144751399](数据库系统原理.assets/image-20210302144751399.png)

18. **关系模式（Relation Schema）**

例如：名（XXX,XXX,）

19. **关系数据库（Relation Database）**

关系数据库是以关系模型作为数据的逻辑模型，并采用关系作为数据组织方式的一类数据库，其数据操作建立在关系代数的基础上。



![image-20210302145248902](数据库系统原理.assets/image-20210302145248902.png)



### 2.2.2 关系操作集合

#### 1.基本的关系操作

- **查询**

选择、投影、连接、除、并、交、差、笛卡尔积

- **数据更新** 

插入、删除、修改

查询的表达能力很强，是其中最主要的部分

- **关系操作的特点**

集合操作方式，即操作对象和结果都是集合 

#### 2.关系数据语言的分类

关系操作的能力可以用两种方式来表示：**代数方式**和**逻辑方式**

![image-20210302150243286](数据库系统原理.assets/image-20210302150243286.png)

#### 3.关系代数

![image-20210302150528336](数据库系统原理.assets/image-20210302150528336.png)

![image-20210302150607106](数据库系统原理.assets/image-20210302150607106.png)





**专门的关系运算**

![image-20210302151202097](数据库系统原理.assets/image-20210302151202097.png)

![image-20210302151326398](数据库系统原理.assets/image-20210302151326398.png)

![image-20210302151441263](数据库系统原理.assets/image-20210302151441263.png)

![image-20210302151642655](数据库系统原理.assets/image-20210302151642655.png)

### 2.2.3 关系的完整性约束

#### 1.实体完整性约束

![image-20210302152115052](数据库系统原理.assets/image-20210302152115052.png)

#### 2.参照完整性约束

![image-20210302152046576](数据库系统原理.assets/image-20210302152046576.png)

#### 3.用户定义完整性约束

![image-20210302152210366](数据库系统原理.assets/image-20210302152210366.png)

#### 4.关系模型完整性约束的检验

![image-20210302152257117](数据库系统原理.assets/image-20210302152257117.png)



例题：

![image-20210302152422499](数据库系统原理.assets/image-20210302152422499.png)

![image-20210302152430447](数据库系统原理.assets/image-20210302152430447.png)





## 2.3 关系数据库的规范化理论

### 2.3.1关系模式中可能存在的冗余和异常问题

- 数据冗余
- 更新异常
- 插入异常
- 删除异常

### 2.3.2 函数依赖于关键字

![image-20210302154528618](数据库系统原理.assets/image-20210302154528618.png)

1.完全函数依赖

![image-20210302154623006](数据库系统原理.assets/image-20210302154623006.png)

2.部分函数依赖

![image-20210302154806549](数据库系统原理.assets/image-20210302154806549.png)

3.传递函数依赖

![image-20210302154906666](数据库系统原理.assets/image-20210302154906666.png)



**关键字**

![image-20210302155218064](数据库系统原理.assets/image-20210302155218064.png)



### 2.3.3 范式于关系规范化国创过程

满足最低要求的称为第一范式，简称为1NF，这是最基本的范式。

![image-20210302160414992](数据库系统原理.assets/image-20210302160414992.png)

（1）第一范式

![image-20210302160525001](数据库系统原理.assets/image-20210302160525001.png)

（2）第二范式

![image-20210302160702299](数据库系统原理.assets/image-20210302160702299.png)

![image-20210302160737263](数据库系统原理.assets/image-20210302160737263.png)

（3）第三范式

![image-20210302160833936](数据库系统原理.assets/image-20210302160833936.png)



**过程**：
![image-20210302160949120](数据库系统原理.assets/image-20210302160949120.png)



### 2.3.4 关系规范化理论的应用

![image-20210302161256343](数据库系统原理.assets/image-20210302161256343.png)





## 小结

![image-20210302161452095](数据库系统原理.assets/image-20210302161452095.png)

![image-20210302161458768](数据库系统原理.assets/image-20210302161458768.png)







# 第三章 数据库设计

## 3.1 数据库设计概述

### 3.1.1 数据库的生命周期 

数据库生命周期分为 两个阶段 ，分别是 **数据库分析与设计阶段**、**数据库实现与操作阶段** 

​	其中，数据库分析与设计阶段包括**需求分析**、**概念设计**、**逻辑设计**和**物理设计**四个环节；数据库实现与操作阶段包括**数据库的实现**、**操作与监督**、**修改与调整**三个子阶段



### 3.1.2 数据库设计的目标

事实上，数据库设计具有两个十分重要的目标，即满足**应用功能需求**和**良好的数据库性能**

 

### 3.1.3 数据库设计的内容

数据库设计从用户对数据的需求出发，研究并构造数据库的过程，包括两个方面的内容:

1. 数据库结构设计
2. 数据库行为设计（crud等等）



### 3.1.4数据库设计的方法

1. 直观设计法

2. 规范设计法*

   （1）新奥尔良设计方法

   （2）基于E-R模型的数据库设计方法

   （3）基于第三范式的设计方法

3. 计算机辅助设计法



### 3.1.5 数据库设计的过程

![image-20210302194916279](数据库系统原理.assets/image-20210302194916279.png)



## 3.2 数据库设计的基本步骤



### 3.2.1 需求分析

1.**确定数据库范围**

![image-20210303084106217](数据库系统原理.assets/image-20210303084106217.png)



2.**应用过程分析**

![image-20210303084808333](数据库系统原理.assets/image-20210303084808333.png)



3.**收集与分析数据**

（1）静态结构

![image-20210303085150564](数据库系统原理.assets/image-20210303085150564.png)

（2）动态结构

![image-20210303085321033](数据库系统原理.assets/image-20210303085321033.png)

（3）数据约束

![image-20210303085336214](数据库系统原理.assets/image-20210303085336214.png)



4.**编写需求分析报告**

报告包含如下内容：
（1）数据库的应用功能分析  -》功能，性能

（2）表明不同用户的试图范围 -》权限类

（3）应用处理过程需求说明

（4）数据字典

（5）数据量

（6）数据约束 -》对特殊的数据作约束



### 3.2.2概念结构设计

![image-20210303091413333](数据库系统原理.assets/image-20210303091413333.png)

其中主要采用**E-R图**作为概念模型的描述工具



### 3.2.3 逻辑结构设计

![image-20210303091607439](数据库系统原理.assets/image-20210303091607439.png)



### 3.2.4 物理设计

![image-20210303091658095](数据库系统原理.assets/image-20210303091658095.png)



### 3.2.5 数据库实施

1.加载数据 -测试

2.应用程序设计 -crud

3.数据库试运行



### 3.2.6 数据库运行和维护

![image-20210303092108584](数据库系统原理.assets/image-20210303092108584.png)

系统维护中最困难的工作是数据库**重组与重构**



## 3.3 关系数据库设计方法

### 3.3.1关系数据库设计过程与各级模式

![image-20210303093115508](数据库系统原理.assets/image-20210303093115508.png)



### 3.3.2概念结构设计方法

#### 1.E-R图的表示方法

三种关系：1:1 ，1：N，N:M 

![image-20210303093620216](数据库系统原理.assets/image-20210303093620216.png)

> 系主任 隶属于 系
>
> 班级 包含 学生
>
> 学生选择课程



两个以上的实体型之间的联系

![image-20210303093832639](数据库系统原理.assets/image-20210303093832639.png)

![image-20210303093900677](数据库系统原理.assets/image-20210303093900677.png)

![image-20210303093948234](数据库系统原理.assets/image-20210303093948234.png)





#### 2.局部信息结构设计

（1）确定局部范围

（2）选择实体

（3）选择实体的关键字属性

（4）确定实体之间的联系

（5）确定实体的属性

![image-20210303094559727](数据库系统原理.assets/image-20210303094559727.png)

![image-20210303094445257](数据库系统原理.assets/image-20210303094445257.png)



#### 3.全局信息结构设计

（1）属性冲突

（2）命名冲突

（3）结构冲突

消除以上冲突得出E-R图

![image-20210303094800694](数据库系统原理.assets/image-20210303094800694.png)



### 3.3.3逻辑结构设计方法

1.E-R图向关系模型的转换

2.数据模型的优化

3.设计用户子模式



### 3.3.4物理设计方法

1.建立索引    -排序

2.建立聚集







## 小结

![image-20210303095732552](数据库系统原理.assets/image-20210303095732552.png)

![image-20210303095808732](数据库系统原理.assets/image-20210303095808732.png)





# 第四章 SQL与关系数据库基本操作



## 4.1 SQL概述

1.SQL的发展

![image-20210303104105416](数据库系统原理.assets/image-20210303104105416.png)



2.SQL的特点

![image-20210303104242929](数据库系统原理.assets/image-20210303104242929.png)

3.SQL的组成

![image-20210303104258870](数据库系统原理.assets/image-20210303104258870.png)



## 4.2 MySQL预备知识

1.Mysql使用基础

![image-20210303104542334](数据库系统原理.assets/image-20210303104542334.png)



2.MYSQL中的SQL		

![image-20210303104658358](数据库系统原理.assets/image-20210303104658358.png)



> **1.常量**
>
> - 字符串常量
>
> ![image-20210303104945736](数据库系统原理.assets/image-20210303104945736.png)
>
> - 数值常量
>
> ![image-20210303105043574](数据库系统原理.assets/image-20210303105043574.png)
>
> 科学计数法0.5E-2 = 0.5 X 10的-2次方
>
> - 16进制常量
>
> ![image-20210303105315302](数据库系统原理.assets/image-20210303105315302.png)
>
> X‘41’ = 4 X 16的1次方 + 1 X 16的0次方 = 65 = A
>
> ![image-20210303105509658](数据库系统原理.assets/image-20210303105509658.png)
>
> - 日期时间常量
>
> ![image-20210303105621258](数据库系统原理.assets/image-20210303105621258.png)
>
> - 位字段值（了解）
>
> ![image-20210303105832916](数据库系统原理.assets/image-20210303105832916.png)
>
> - 布尔值
>
> ![image-20210303105858014](数据库系统原理.assets/image-20210303105858014.png)
>
> - Null值
>
> ![image-20210303105934089](数据库系统原理.assets/image-20210303105934089.png)



> **2.变量**
>
> 用户在表达式中使用自己定义的变量，这样的变量叫做**用户变量**
>
> ![image-20210303110421818](数据库系统原理.assets/image-20210303110421818.png)
>
> 用户变量前加 **@**来区分列名
>
> 必须在系统变量前加**两个@**



> 3.**运算符**
>
> - 算术运算符
>
> ![image-20210303110742772](数据库系统原理.assets/image-20210303110742772.png)
>
> - 位运算符
>
> ![image-20210303110811814](数据库系统原理.assets/image-20210303110811814.png)
>
> 左移X2 右移除2
>
> - 比较运算符（关系运算符）
>
> 用于比较两个表达式的值
>
> ![image-20210303142105516](数据库系统原理.assets/image-20210303142105516.png)
>
> - 逻辑运算符
>
> ![image-20210303150254861](数据库系统原理.assets/image-20210303150254861.png)
>
> 





> 4.表达式 
>
> ![image-20210303150928757](数据库系统原理.assets/image-20210303150928757.png)



> 5.内置函数
>
> ![image-20210303151026707](数据库系统原理.assets/image-20210303151026707.png)
>
> ABS（）取绝对值
>
> SORT（）开方
>
> 





## 4.3 数据定义

### 4.3.1 数据库模式定义

1.创建数据库

![image-20210303151958357](数据库系统原理.assets/image-20210303151958357.png)



![image-20210304084810587](数据库系统原理.assets/image-20210304084810587.png)

2.选择数据库

~~~
Use db_name;
~~~





3.修改数据库

![image-20210304084858042](数据库系统原理.assets/image-20210304084858042.png)



4.删除数据库

![image-20210304085000281](数据库系统原理.assets/image-20210304085000281.png)



5.查看数据库

![image-20210304085023178](数据库系统原理.assets/image-20210304085023178.png)





### 4.3.2 表定义

> - 数值类型：
>   - 整数类型 INT
>   - 浮点型 FLOAT DOUBLE DECIMAL
> - 日期和时间类型：
>   - 日期类型 DATE （YYYY-MM-DD）
>   - 日期时间类型 DATETIME TIME
>   - 时间戳类型 TIMESTEAMP
> - 字符串类型：
>   - 固定长度类型 CHAR 最大长度255
>   - 可变长度类型 VARCHAR 最大长度 65535
>   - 文本类型 TEXT



**1.创建表**

![image-20210304090544713](数据库系统原理.assets/image-20210304090544713.png)

> ImaDB
>
> MyISAM
>
> mysql 两个引擎



> **添加字段**

![image-20210304090724504](数据库系统原理.assets/image-20210304090724504.png)



> **修改字段**

![image-20210304091100679](数据库系统原理.assets/image-20210304091100679.png)



> **删除字段**

![image-20210304091130647](数据库系统原理.assets/image-20210304091130647.png)



> **重命名表**

![image-20210304091147319](数据库系统原理.assets/image-20210304091147319.png)



> **删除表**

![image-20210304091238471](数据库系统原理.assets/image-20210304091238471.png)



> **查看表**

![image-20210304091300998](数据库系统原理.assets/image-20210304091300998.png)



> 查看表结构

![image-20210304091332567](数据库系统原理.assets/image-20210304091332567.png)

![image-20210304091342280](数据库系统原理.assets/image-20210304091342280.png)



### 4.3.3 索引定义

![image-20210304092713480](数据库系统原理.assets/image-20210304092713480.png)



> **索引** 

用途划分：

- 普通索引（INDEX）
- 唯一性索引（UNIQUE）
- 主键（PRIMARY KEY）
- 全文索引（FULLTEXT）需使用[引擎MyISAM]
- 聚簇索引   [引擎InnoDB]

列级索引：

- 单列索引
- 组合索引





1.**索引的创建**

![image-20210304093325549](数据库系统原理.assets/image-20210304093325549.png)

![image-20210304093415546](数据库系统原理.assets/image-20210304093415546.png)

> 常用 CREATE INDEX
>
> ```sql
> CREATE [UNQIUE] INDEX index_name On tbl_name(col_name[(length)][ASC|DESC],...)
> ```



**2.索引的查看**

![image-20210304093930519](数据库系统原理.assets/image-20210304093930519.png)



3.**索引的删除**

![image-20210304094330311](数据库系统原理.assets/image-20210304094330311.png)





## 4.4 数据更新

### 4.4.1 插入数据

INSERT 语法格式：

> ~~~sql
> INSERT INTO tb_name (column_list) VALUES(value_list1)[,(value_list2)]
> ~~~

column_list 需要与value_list1 对应，包括数据类型

![image-20210304095657865](数据库系统原理.assets/image-20210304095657865.png)



使用INSERT...SET语句插入部分列值数据

~~~sql
INSERT tb_name SET col_name = {expr|DEFAULT}....
~~~

![image-20210304100025144](数据库系统原理.assets/image-20210304100025144.png)



### 4.4.2 删除数据

![image-20210304105532307](数据库系统原理.assets/image-20210304105532307.png)



### 4.4.3  修改数据 

![image-20210304105624186](数据库系统原理.assets/image-20210304105624186.png)





## 4.5 数据查询

### 4.5.1 SELECT语句

![image-20210304110534490](数据库系统原理.assets/image-20210304110534490.png)



![image-20210304111006271](数据库系统原理.assets/image-20210304111006271.png)

> group by 聚合函数
>
> having 聚合后使用
>
> order by 按照....来排序
>
> limit 取全部中的...条数据



![image-20210304111238987](数据库系统原理.assets/image-20210304111238987.png)

### 4.5.2 列的选择与指定

1.选择指定的列

~~~sql
select classNo，department，className from tb_class
~~~

![image-20210304111402043](数据库系统原理.assets/image-20210304111402043.png)



选择所有列

~~~sql
select * from tb
~~~



2.定义并使用列的别名

![image-20210304111527945](数据库系统原理.assets/image-20210304111527945.png)





3.替换查询的结果集中的数据

![image-20210304111746478](数据库系统原理.assets/image-20210304111746478.png)



4.计算列值

![image-20210304111824935](数据库系统原理.assets/image-20210304111824935.png)



5.聚合函数

主要的聚合函数

| 函数名 | Dec说明                |
| ------ | ---------------------- |
| COUNT  | 求组中的所有项数       |
| MAX    | 求最大值               |
| MIN    | 求最小值               |
| SUM    | 返回表达式中所有值得和 |
| AVG    | 求组中值得平均值       |

其他：

![image-20210304112155350](数据库系统原理.assets/image-20210304112155350.png)

> `例如`：
>
> ~~~sql
> select count(*) from rec where num>150
> ~~~
>
> 

### 4.5.3 FROM子句 与多表连接查询

**1.交叉连接**

**2.内连接**

![image-20210304112304294](数据库系统原理.assets/image-20210304112304294.png)

`例如：`

> ```SQL
> select * from gong join rec on gong.gno = rec.gno
> ```



**3.外连接**

左连接：

~~~sql
FROM table1 [LEFT] join table2 ON 连接条件
~~~

右连接：

~~~SQL
from table1 [RIGHT] JOIN table2 ON 连接条件
~~~



> 没能找到则以空的形式是显示



### 4.5.4 WHERE 字句与条件查询

![image-20210304144408152](数据库系统原理.assets/image-20210304144408152.png)



> **子查询**
>
> *IN语法：*
> WHERE 列名 IN（值列表或者子SELECT[但必须有一列]）
>
> *比较运算符：*
>
> WHERE 列名 <比较运算符> （值或者子SELECT[但必须只有一值]）
>
> *EXIST查询：*
>
> WHERE EXIST （子SELECT）



### 4.5.5 GROUP BY子句 与分组数据

**语法**：[GROUP BY 字段列表] [HAVING<条件表达式>]

**含义**：按照某一列的值相同的分成一组，进行聚合运算



> HAVING子句

在SELECT 语句中，除了能使用Group by 子句分组数据之外，还可使用Having 子句来过滤分组，即在结果集中规定包含哪些分组和排除哪些分组



> ORDER BY 字句

语法：[ORDER BY 字段1[ASC] [DASC] [,字段2[ASC] [DASC]] ]

ASC：升



> LIMIT子句

LIMIT [位置偏移量，]行数

~~~sql
select sum(price*num),rec.*from rec group by gno limit 0,3;
~~~

​	limit 0,3 指从第0条开始，只要前三条

​	limit1,3 只从第一条开始



`tips：`

**数据库定义语言：**

- create
- alter
- drop

**数据库操纵语言：**

- C R U D

**数据库控制语言：**

- GRANT：用于授予权限，可把语句许可或对象许可的权限授予其他用户和角色。
- REVOKE：用于回收权限，其功能与GRANT相反，但不影响该用户或角色从其他角色中作为成员继承许可权限





## 4.6 视图

视图是从一个或多个表（或视图）导出的表。视图是数据库用户使用数据库的观点。**视图是一张虚表**。

视图一经定义以后，就可以像表一样可以被查询，修改，删除，和更新。



### 4.6.1 创建视图

> *语法格式*：
>
> ~~~sql
> create [OR REPLACE] [algorithm = {undefined | merge | temptable}] VIEW view_name as select_statement [with[cascaded | local] check option]
> ~~~
>
> - replace 如果已有视图 选择是否覆盖
> - [with[cascaded | local] check option] 选择 是否检查视图，cascaded所有视图，local本地视图





### 4.6.2 删除视图

> *语法格式：*
>
> ~~~sql
> DROP VIEW [IF EXISTS] view_name [,view_name]...
> ~~~

~~~sqsl
drop view if exists v_name1
~~~



### 4.6.3 修改视图定义

> *语法格式：*
>
> ~~~sql
> alter view view_name [(olumn_list)] 
> as select_statement
> [with [cascaded | local] check option]
> ~~~



### 4.6.4 查看视图定义

> *语法格式：*
>
> ~~~sql
> show create view view_name
> ~~~







### 4.6.5 更新视图数据

​		要通过试图更新基本数据基本表，必须保证视图是可更新视图，即可以在INSERT、UPDATE或者DELETE等语句当中使用他们。对于可更新的视图，**在视图的行和基本表中之间必须具有一对一的关系**，还有一些特殊的其他结构，这类结构会使得视图不可更新。

### 4.6.6 查询视图数据

​		视图一经定以后，就可以如同查询数据库中的真实表一样，**对视图进行数据查询检索**，这也是对视图使用最多的一种操作。

~~~sql
select * from V_name
#包括where like 语句
select * from v_name where name like 'X%'
~~~







## 小结

![image-20210308134046997](数据库系统原理.assets/image-20210308134046997.png)



![image-20210308134201991](数据库系统原理.assets/image-20210308134201991.png)

![image-20210308141734027](数据库系统原理.assets/image-20210308141734027.png)





# 第五章 数据库编程



## 5.1 存储过程

### 5.1.1 存储过程的基本概念

​		存储过程是一组为了完成某项特定功能的SQL语句集，**其实质就是一项存储在数据库的代码**，它可以有声明式的SQL语句（例如create、update、select等语句 ）和过程式sql语句（如 IF .... then ...else控制结构语句组成）





> **使用存储过程的有点**：*
>
> 1. 提高运行速度；
> 2. 增强Sql功能和灵活性；
> 3. 可以降低网络的通信量
> 4. 减轻了程序编写的工作量
> 5. 提高了安全控制功能



### 5.1.2创建存储过程

> ##### 语法格式：
>
> ~~~sql
> create procedure sp_name ([proc_parameter[,...]]) [characteristic..] routine_body[begin .... end] 
> #其中，proc_parameter的参数如下：
> [in|out|inout] param_name type
> ~~~

可选项

~~~sql
characteristic特征如下：
language SQL
|[not] deterministic
|{contains sql|no sql|reads sql data|modifies sql data}
|sql security {definer|invoker}
|comment 'string'
~~~



> ##### delimiter语法格式：
>
> ~~~sql
> delimiter $$
> 修改结束符为 $$
> ~~~
>
> 说明：
>
> 因mysql中运行命令的结束符号为 **； 分号**，因此编写存储为避免冲突，**修改结束符号为$$**



### 5.1.3 存储过程体

1. **局部变量**

在存储过程中可以声明局部变量，它们可以用来存储临时结果。

要声明局部变量必须使用 DECLARE （declare）语句。在声明局部变量的同时也可以对其赋一个初始值

> ##### declare的语法格式如下：
>
> ~~~sql
> declare var_name[,...] type [default value]
> ~~~
>
> 说明：
>
> var_name 变量名；type 为变量类型；
>
> default 子句给变量指定一个默认值，如果不指定默认为null。
>
> 例如 declare XXX CHAR（10）
>
> **注意：**
>
> 如果定义的局部变量名与定义的字段名 一致 ，则数据类型和长度也需一致 



2. **SET语句**

要给局部变量赋值可以使用SET语法，SET语句也是SQL本身的一部分

> ##### 语法格式：
>
> ~~~sql
> > SET var_name = expr[, var_name = expr ]...
> 
> ~~~



3. **SELECT ...INTO 语句**

使用这个SELECT ....INTO 语句可以吧选定的列值存储到变量中。因此，**返回的结果只能有一行**

> ##### 语法格式：
>
> ~~~sql
> SELECT col_name[,...]INTO var_name[,...] table_expr
> ~~~
>
> 说明: col_name是列名，var_name 是要赋值的变量名table_expr是SELECT语句中的FROM子句及后面的部分



4.**流程控制语句**

（1）==IF语句==

IF-THEN-ELSE 语句可以根据不同的条件执行不同的操作

> ##### 语法格式：
>
> ~~~sql
> if search_condition then statement_list
> #后面可以跟多个条件
> [ELSEIF search_condition then statement_list]
> [else statement_list]
> END IF
> ~~~
>
> 说明：search_condition是判断的条件，statement_list中包含一个或多个SQL语句。当search_condirion的条件为真时，就执行相应的Sql语句。
>
> 注意：**区别IF（）函数**，不要混淆

（2）==CASE语句==

> **说明：**
>
> 一个case语句经常可以充当一个IF-THEN-ELSE语句
>
> **形式一：**
>
> ~~~sql
> case case_value 
> when when_value then statement_list
> 	[when when_value then statement_list]
> 	[else statement_list]
> end case
> #case_value:表达式或者值
> #when_value:与case_value相比较
> ~~~
>
> **形式二：**
>
> ~~~sql
> case
> 	when search_condition then statement_list
> 	[when search_condition then statement_list]
> 	[else statement_list]
> END CASE
> search_condition:指定一个比较表达式
> ~~~

（3）==循环语句==

MySql支持3条用来创建循环的语句：while 、repeat、loop语句。在存储过程中可以定义0个或多个循环语句。

循环语句说明:

- WHILE 先判断，REPEAT后判断，WHILE 条件为真进行循环，REPEAT 条件为真结束循环
- 在LOOP循环内的语句一直重复至循环被退出，退出时通常伴随着一个LEAVE 语句
- LEAVE 语句经常和BEGIN ... END 或循环一起使用
- LEAVE label  

> **形式一**：
>
> ~~~sql
> [brgin_label:]
> WHILE
> search_condition
> DO
> 	statement_list
> END WHILE
> [end_label]
> ~~~
>
> **形式二：**
>
> ~~~sql
> [begin_label:]
> REPEAT
> 	sql 语句列表
> UNRIL 
> 	搜索条件
> END REPEEAT
> [end_label]
> ~~~
>
> **形式三：**
>
> ~~~sql
> [begin_label:]
> LOOP
> 	sql 语句列
> END LOOP
> [end_label]
> ~~~



5. **游标**

一条SELECT ...INTO 语句返回的是带有的一行,这样可以把数据读取到存储过程中。但是常规的SELECT 语句返回的是多行数据，所以为处理它需要引入游标这一概念

Mysql中游标要唯一,游标本身是执行SELECT 检索出来的结果集

（1）==**声明游标**==

> **语法格式**
>
> ~~~sql
> DECLARE cursor_name  cursor for
> select_statement
> ~~~
>
> 说明：cursor_name是游标的名称，游标名称使用与表名同样的规则。select_statement为select 语句，返回一行或者多行数据

（2）==**打开游标**==

声明游标后，要使用 游标从中提取数据，就必须先打开游标。在mysql 中，使用OPEN语句打开游标，其格式为：

~~~sql
OPEN cursor_name (游标名 )
~~~

在程序中每一个游标可以打开多次，由于其他用户或程序可能已经更新了表，所以每次打开结果可能不同

（3）==**读取数据**==

游标打开后，就可以使用FETCH... INTO语句从中读取数据

> **语法格式**：
>
> ~~~sql
> FETCH cursor_name INTO var_name[,var_].
> ~~~
>
> 说明：FETCH...INTO 语法与SELECT ...INTO 语句具有相同的意义，FETCH语句是将游标指向的一行数据赋给一些变量，子句中变量的数目必须等于声明游标时
>
> SELECT子句中列的数目。var_name 是存放数据的变量名。

（4）==**关闭游标**==

游标使用完以后，要及时关闭，关闭游标使用CLOSE语句，格式为：

~~~sql
CLOSE 游标名
~~~

语句参数的含义与OPEN语句中相同



### 5.1.4 调用存储过程

存储过程创建完后，可以再程序、触发器或者存储过程中被调用，但是都必须要用到CALL语句

> **语法格式**：
>
> ~~~sql
> CALL sp_name([parmeter[,...]])
> ~~~
>
> 说明：sp_name为存储过程中的名称，如要调用某个特定数据库的存储过程，则需要在前面加上该数据库的名称。
>
> parameter为调用该存储过程中使用的参数吗，这条语句中的参数必须总是等于存储过程的参数个数。



### 5.1.5  删除存储过程 

存储过程创建后需要删除使用DROP procedure 语句。在这之前，**必须确认该存储过程没有任何依赖关系**，否则会导致其他与之关联的存储过程无法运行。

> 语法格式：
>
> ~~~sql
> drop procedure [if exits] sp_name
> ~~~
>
> 说明：
>
> sp_name 是要删除的存储过程的名称，
>
> [if exits]子句是MySql的扩展，如果程序或函数不存在，它防止发生错误





## 5.2 存储函数

### 5.2.1 创建存储函数

创建存储函数使用 create function 语句。要查看数据库中有哪些存储函数，可以使用show function status命令

> **语法格式：**
>
> ~~~sql
> CREATE FUNCTION 函数名 ([func_parameter[,..]])
> 	RETURNS type #指定输出和输出类型 
> 	[char acteristic ...] routine_body
> ~~~
>
> 说明：
> 存储函数的定义格式和存储过程相差不大

### 5.2.2 调用存储函数

存储函数创建完后，就同系统提供的内置函数（如VERSION()）,所以调用存储函数的方法也差不多，都是使用SELECT 关键字

> **语法格式**：
>
> ~~~sql
> SELECT 函数名 ([函数参数[,...]])
> ~~~



5.2.3 删除存储函数

删除存储函数与删除存储过程基本一致

使用DROP function 语句

语法格式为：

~~~
drop funition [if exists] 函数名
~~~

> [if exists] 如果存在





## 小结

![image-20210309151447097](数据库系统原理.assets/image-20210309151447097.png)

![image-20210309151522072](数据库系统原理.assets/image-20210309151522072.png)



# 第六章 数据库安全与保护

## 6.1 数据库完整性

### 6.1.1 完整约束条件的作用对象

1. 列级约束

列级约束主要指对列的**类型**、**取值范围**、**精度**等的约束

2. 元祖约束

元祖约束指元组中各个字段之间的相互约束，例如某个活动的开始日期小于结束日期

3. 表级约束

表级约束指若干元组之间、关系之间的联系的约束



### 6.1.2 定义与实现完整性约束

1.**实体完整性**：保证记录不重复，其中至少有一列值不重复，用PRIMARY KEY 添加约束

例如： 列级约束StuNo char(10) PRIMARY KEY

![image-20210309153558773](数据库系统原理.assets/image-20210309153558773.png)



> 候选键约束用关键字UNIQUE 进行约束
>
> Mysql中候选键 与主键之间存在 以下几点区别：
>
> - 一个表中只能创建一个主键，但可以定义若干个候选键
> - 定义主键约束时，系统会自动产生PRIMARY KEY 索引，而定义候选键约束时，系统会自动产生UNIQUE 索引

2.**参照完整性**：主要指两个表之间的关系，比如课程开设依赖于教师表，没有教师就不应该有教师的课

**保证数据的正确性**

> 语法格式：
>
> ~~~sql
> references tbl_name表名[index_col_name]
> ~~~
>
> tbl_name l另外的一张表与主键index_col_name的关系



3.**自定义完整性：**

非空约束

​		在create 、alter table 语句某个列定义后面，加上关键字’not null‘作为限定词

> 用户自己定义的约束：
> 语法格式如下：
>
> ~~~sql
> CHECK(expr)
> ~~~
>
> check (跟表达式)



### 6.1.3 命名完整性约束

语法格式为：

~~~sql
constraint[symbol]
~~~

symbol 外键约束名

### 6.1.4 更新完整性约束

1.**删除约束**

> ALTER TABLE <表名> drop foreign key <外键约束名>
>
> alter table <table_name> drop primary key
>
> alter table <table_name> drop{约束名|候选键字段名} 

2.**添加约束**

~~~sql
alter table <表名> add [constraint <约束名>]
primary key (主键字段)

alter table <表名> add [constraint <约束名>]
foreign key (外键字段名) refernces 被参照表（主键字段名）；
alter table <表名> add [constraint] <约束名>]
unique key (主键字段)
~~~



## 6.2 触发器

### 6.2.1 创建触发器

触发器是保护表数据的数据库对象，当指定的表发生 INSERT（插入），UPDATE（修改数据），DELETE（删除）的时候会触发，进行相应的动作。

注意：查询（select）动作不会触发 触发器

![image-20210310084919451](数据库系统原理.assets/image-20210310084919451.png)

> 语法格式：
>
> ~~~sql
> create trigger 触发器名 触发器时间
> 触发器时间（trigger event） 
> On tbl_name for each row trigger_body
> ~~~
>
> for each row 对于哪一行
>
> trigger_body 触发内容



### 6.2.2 删除触发器

> 语法格式：
>
> ~~~sql
> drop trigger [if exist是否存在][schema_name.某一个数据库]trigger_name 触发器名
> ~~~



使用触发器

> 增加 ，修改，删除 都会 触发 触发器



## 6.3 安全性与访问控制

### 6.3.1 用户账号管理

1.**创建用户账号**

> **语法格式**：
>
> ~~~sql
> create USER user [IDENTIFIED BY [PASSWORD] 'password']
> 	[,user [IDENTIFIED BY [PASSWORD]'password']]...
> 	其中，user 的格式为：
> 'user_name'@'host name'
> 用户名 @ 主机名
> ~~~
>
> 格式说明：
> 使用自选的IDENTIFIED BY子句，可以为账户给定一个密码。

查看用户信息

~~~sql
select user,password from mysql.user 
~~~



2.**删除用户**

> **语法格式**：
>
> ~~~sql
> drop USER user [,用户名]...
> ~~~
>
> drop USER可删除一个或多个账号，**并取消其权限**。要使用DROP USER，必须拥有mysql数据库全局create USER 权限或者删除权限。
>
> 注意：不能删除root



3. **修改用户账户**

> **语法格式**：
>
> ~~~sql
> rename user old_user TO new_user,
> ~~~
>
> rename user 语句用于对**原有MYSQL 账户进行重命名。**要使用rename USER，必须拥有mysql数据库全局create USER 权限或者update权限。



4.修改用户口令：

> **语法格式**：
>
> ~~~sql
> SET PASSWORD [FOR USER]=PASSWORD('新密码')
> ~~~
>
> 说明：
> 如果不加上for user 则默认修改当前用户的密码
>
> for user 则是修改当前主机上的特定用户的密码
>
> user为用户名。user的值必须以'user_name'@'host_name'的格式给定



### 6.3.2 账户权限管理

#### 1.权限的授予：

新的sql用户不允许 访问属于其他sql用户的表，也不能立即创建自己的表，它必须被授权。可以授予的权限有以下几组。

- 列权限：和表中的一个具体列相关。
- 表权限：和一个具体表中的所有数据相关。
- 数据库权限：和一个具体的数据库中的所有表相关。
- 用户权限：和mysql所有的数据库相关。

> ​	给某用户授予权限可以使用GRANT语句。使用SHOW GRANTS 语句可以查看当前用户拥有的权限

GRANT 语法格式：

~~~sql
grant priv_type（赋予的权限名称）
ON[Object_type]（在什么对象上）{表名|数据库名}
TO user []'password'
~~~

priv_type 为权限的名称，如select

to子句用来设定用户的密码

on关键字后面给出的是要授予权限的数据库或表名



**授予表权限和列权限**

> 授予表权限时，priv_type 可是以下值：
>
> - select ：给予用户访问特定表的权限
> - insert：给予用户使用插入语句向一个特定表中添加行的权限
> - delete：删除行的权利
> - update：使用修改语句修改特定表中的值得权限
> - references：语序用户创建外键
> - create ：允许用户创建表
> - alter：修改表
> - index：建立索引
> - drop：删除表
> - ALL或者all privileges:表示所有权限

授予表权限时，on后面跟表名或视图名



**授予列权限**：

> 只能赋予select、insert和update 同时权限的后面需加上列名



**授予数据库权限**

> - select
> - insert
> - delete
> - update
> - references
> - create routine 创建存储过程 
> - alter routine：修改存储过程
> - execute toutine：调用存储过程
> - lock tables：给予用户锁定表
> - all 或all privileges



在grant语法格式中，授予数据库权限时 on关键字后面跟 “ * ”和“ db_name.* ”；

> ' * ' 表示当前数据库中所以的表
>
> ' db_name '表示某个数据库中所有表 



**授予用户权限**

最有效率的权限就是用户权限，对于需要授予数据库权限的所有语句，也可以定义在用户权限上

> - create user
> - show datebase